<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EAT ¬∑ AVOID ‚Äî  two‚Äëkey game</title>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
        }
        body {
            margin: 0;
            min-height: 100vh;
            background: linear-gradient(145deg, #1b322c 0%, #2f5e4a 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', Roboto, system-ui, sans-serif;
            padding: 16px;
        }
        .game-container {
            background: #3a2e1f;
            background-image: radial-gradient(circle at 25% 20%, #5f4c33, #2f2418);
            padding: 24px 24px 30px 24px;
            border-radius: 56px 56px 48px 48px;
            box-shadow: 0 25px 35px rgba(0,0,0,0.7), inset 2px 2px 8px rgba(255,215,140,0.3);
            border: 3px solid #b1955b;
        }
        canvas {
            display: block;
            margin: 0 auto;
            width: 600px;
            height: 400px;
            border-radius: 32px;
            background: #1f4d3a;
            background-image: 
                radial-gradient(circle at 30% 40%, #3b8864 5%, transparent 30%),
                radial-gradient(circle at 80% 70%, #256c4b 15%, transparent 40%),
                linear-gradient(145deg, #1f4d3a, #0f3324);
            box-shadow: inset 0 -4px 8px #0e2f1e, inset 0 4px 6px #6fba91, 0 15px 18px #1f2c1c;
            cursor: none;
            border: 4px solid #caad73;
        }
        .panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 20px 12px 8px 12px;
            color: #f9eac3;
            text-shadow: 3px 3px 0 #4d3e1f, 1px 1px 0 #00000088;
            font-weight: 800;
            letter-spacing: 1px;
        }
        .score-board {
            background: #281f10;
            padding: 12px 28px;
            border-radius: 60px;
            font-size: 28px;
            box-shadow: inset 0 2px 5px #ac9a6b, 0 7px 0 #0a0804;
            border-bottom: 2px solid #e9ca91;
            color: #ffe9af;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .score-board span {
            font-size: 42px;
            line-height: 1;
            color: #ffcf8a;
            margin-right: 6px;
        }
        .keys {
            background: #46381f;
            padding: 10px 24px;
            border-radius: 60px;
            font-size: 22px;
            box-shadow: inset 0 1px 5px #ebd39f, 0 5px 0 #2c1f0e;
            border-bottom: 2px solid #b6904b;
        }
        .keys kbd {
            background: #191007;
            color: #fbe593;
            border-radius: 16px;
            padding: 6px 16px;
            margin: 0 4px;
            font-size: 26px;
            font-weight: 900;
            border: 1px solid #dbb05c;
            box-shadow: 0 3px 0 #5b3f18;
        }
        button {
            background: #c49a4f;
            border: none;
            color: #1d2b14;
            font-size: 28px;
            font-weight: bold;
            padding: 12px 40px;
            border-radius: 40px;
            letter-spacing: 2px;
            box-shadow: 0 9px 0 #6f4f24, 0 5px 15px black;
            transition: 0.07s ease;
            cursor: pointer;
            text-transform: uppercase;
            border-bottom: 3px solid #fbd27e;
            margin-top: 10px;
        }
        button:active {
            transform: translateY(7px);
            box-shadow: 0 3px 0 #6f4f24, 0 5px 12px black;
        }
        .footer {
            text-align: center;
        }
        .status {
            background: #130e07b0;
            border-radius: 40px;
            padding: 8px 30px;
            font-size: 22px;
            color: #efdbab;
            backdrop-filter: blur(2px);
            display: inline-block;
        }
    </style>
</head>
<body>
<div class="game-container">
    <canvas id="gameCanvas" width="600" height="400"></canvas>

    <div class="panel">
        <div class="score-board">
            <span>üçé</span> <span id="scoreDisplay">0</span>
        </div>
        <div class="keys">
            <kbd>‚Üê</kbd>  <kbd>‚Üí</kbd>  ¬∑  eat apple ¬∑ avoid skull
        </div>
    </div>

    <div class="footer">
        <button id="restartButton">‚Üª  new meal</button>
        <div id="gameStatus" class="status" style="margin-top: 12px;">‚¨ÖÔ∏è  move & eat</div>
    </div>
</div>

<script>
    (function() {
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreSpan = document.getElementById('scoreDisplay');
        const statusDiv = document.getElementById('gameStatus');

        // ---------- FIXED PARAMETERS ----------
        const PLAYER_WIDTH = 28;       // rectangular player (mouth/plate)
        const PLAYER_HEIGHT = 30;
        const PLAYER_FIXED_Y = 340;     // near bottom, walking on "ground"

        const APPLE_SIZE = 22;           // tasty apples
        const SKULL_SIZE = 22;           // dangerous enemies

        // initial positions
        const PLAYER_START_X = 280;

        // speeds
        const PLAYER_SPEED = 5.3;        // per frame (key move)
        const FALLING_SPEED = 2.2;        // objects move down per frame

        // spawn timing (frames)
        const SPAWN_FRAME_INTERVAL = 38;   // frames between spawns

        // ---------- GAME STATE ----------
        let player = {
            x: PLAYER_START_X,
            y: PLAYER_FIXED_Y,
            w: PLAYER_WIDTH,
            h: PLAYER_HEIGHT
        };

        let apples = [];          // each apple: { x, y, size }
        let skulls = [];          // each skull: { x, y, size }

        let score = 0;
        let gameActive = true;      // true = running, false = game over

        let frameCounter = 0;
        let animationId = null;

        // movement flags (left / right)
        let leftPressed = false;
        let rightPressed = false;

        // ---------- HELPER FUNCTIONS ----------
        function resetGame() {
            gameActive = true;
            score = 0;
            apples = [];
            skulls = [];
            player.x = PLAYER_START_X;
            leftPressed = false;
            rightPressed = false;
            frameCounter = 0;
            statusDiv.innerText = '‚¨ÖÔ∏è  move & eat';
            updateScore();
        }

        function updateScore() {
            scoreSpan.innerText = score;
        }

        // ---------- COLLISION DETECTION (rect overlap) ----------
        function rectCollide(r1, r2) {
            return !(r2.x > r1.x + r1.w || r2.x + r2.w < r1.x ||
                r2.y > r1.y + r1.h || r2.y + r2.h < r1.y);
        }

        // ---------- SPAWN ITEMS (apple or skull) ----------
        function maybeSpawnItem() {
            if (!gameActive) return;

            // random between apple (0) or skull (1) ‚Äì 60% apple, 40% skull for fairness
            const isApple = Math.random() < 0.6;    // 60% apple

            const size = isApple ? APPLE_SIZE : SKULL_SIZE;
            // random x within canvas (with border padding)
            const x = 20 + Math.random() * (canvas.width - size - 40);
            const y = -size - Math.random() * 10;  // start just above canvas

            const newItem = {
                x: x,
                y: y,
                w: size,
                h: size
            };

            if (isApple) {
                apples.push(newItem);
            } else {
                skulls.push(newItem);
            }
        }

        // ---------- UPDATE (move items, collisions, game rules) ----------
        function updateGame() {
            if (!gameActive) return;

            // 1. move player left/right (keyboard)
            if (leftPressed) {
                player.x = Math.max(2, player.x - PLAYER_SPEED);
            }
            if (rightPressed) {
                player.x = Math.min(canvas.width - player.w - 2, player.x + PLAYER_SPEED);
            }

            // 2. move apples & skulls downward
            for (let apple of apples) {
                apple.y += FALLING_SPEED;
            }
            for (let skull of skulls) {
                skull.y += FALLING_SPEED;
            }

            // 3. check collisions (player vs apples) ‚Äì EAT
            const applesToKeep = [];
            for (let apple of apples) {
                if (rectCollide(player, apple)) {
                    // apple collected ‚Üí increase score
                    score++;
                    updateScore();
                    // do NOT push to applesToKeep (remove)
                } else {
                    // keep apple if not eaten AND not below ground (out of screen)
                    if (apple.y + apple.h < canvas.height + 10) { // keep if not completely off screen
                        applesToKeep.push(apple);
                    }
                }
            }
            apples = applesToKeep;

            // 4. check collisions (player vs skulls) ‚Äì AVOID ‚Üí GAME OVER
            for (let skull of skulls) {
                if (rectCollide(player, skull)) {
                    gameActive = false;
                    statusDiv.innerText = 'üíÄ GAME OVER ¬∑ press restart';
                    break; // stop checking further skulls
                }
            }

            // 5. if game still active, remove skulls that left the bottom (to keep memory low)
            if (gameActive) {
                const skullsToKeep = [];
                for (let skull of skulls) {
                    if (skull.y + skull.h < canvas.height + 20) { // keep if mostly inside
                        skullsToKeep.push(skull);
                    }
                }
                skulls = skullsToKeep;
            } else {
                // if game over, we stop updating items (freeze) but still draw them for effect
                // but we can also keep them as is ‚Äì drawing uses same arrays
            }

            // 6. spawn new items based on frameCounter (only if active)
            if (gameActive) {
                if (frameCounter % SPAWN_FRAME_INTERVAL === 0) {
                    maybeSpawnItem();
                }
                frameCounter = (frameCounter + 1) % 10000; // avoid huge numbers
            }
        }

        // ---------- DRAWING ----------
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ---- background details (static) ----
            ctx.fillStyle = '#1f4d3a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // ground line
            ctx.beginPath();
            ctx.strokeStyle = '#ac874b';
            ctx.lineWidth = 6;
            ctx.setLineDash([18, 20]);
            ctx.beginPath();
            ctx.moveTo(0, 368);
            ctx.lineTo(canvas.width, 368);
            ctx.stroke();
            ctx.setLineDash([]); // reset

            // soft shadow
            ctx.shadowColor = '#00000060';
            ctx.shadowBlur = 12;
            ctx.shadowOffsetY = 3;

            // ---- draw apples ----
            for (let a of apples) {
                // apple with leaf
                ctx.fillStyle = '#e63e2e';
                ctx.beginPath();
                ctx.ellipse(a.x + a.w/2, a.y + a.h/2, a.w/2, a.h/2, 0, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = '#7fba3b';
                ctx.beginPath();
                ctx.ellipse(a.x + a.w*0.7, a.y + 2, 5, 8, 0.2, 0, Math.PI*2);
                ctx.fill();
                // little seed
                ctx.fillStyle = '#3f2b10';
                ctx.beginPath();
                ctx.arc(a.x + a.w/2, a.y + a.h/2-2, 2, 0, 2*Math.PI);
                ctx.fill();
            }

            // ---- draw skulls (enemies) ----
            for (let s of skulls) {
                ctx.fillStyle = '#bbbbd0';
                ctx.beginPath();
                ctx.ellipse(s.x + s.w/2, s.y + s.h/2, s.w/2.2, s.h/2.2, 0, 0, Math.PI*2);
                ctx.fill();
                // eyes
                ctx.fillStyle = '#1e1a2b';
                ctx.beginPath();
                ctx.arc(s.x + s.w*0.3, s.y + s.h*0.4, 4, 0, 2*Math.PI);
                ctx.arc(s.x + s.w*0.7, s.y + s.h*0.4, 4, 0, 2*Math.PI);
                ctx.fill();
                // nose / cross
                ctx.fillStyle = '#5a4f6e';
                ctx.fillRect(s.x + s.w*0.45, s.y + s.h*0.6, 3, 8);
                ctx.fillRect(s.x + s.w*0.55, s.y + s.h*0.6, 3, 8);
            }

            // ---- draw player (the hungry rectangle) ----
            ctx.shadowColor = '#ffdd9980';
            ctx.shadowBlur = 20;
            ctx.shadowOffsetY = 5;
            // base plate / body
            ctx.fillStyle = '#ffc164';
            ctx.beginPath();
            ctx.roundRect(player.x, player.y, player.w, player.h, 12);
            ctx.fill();
            // face / mouth
            ctx.fillStyle = '#b16d2e';
            ctx.beginPath();
            ctx.ellipse(player.x+player.w/2, player.y+player.h-6, 10, 6, 0, 0, Math.PI*2);
            ctx.fill();
            // eyes
            ctx.fillStyle = '#2b1c0b';
            ctx.beginPath();
            ctx.arc(player.x+7, player.y+10, 4, 0, 2*Math.PI);
            ctx.arc(player.x+player.w-7, player.y+10, 4, 0, 2*Math.PI);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(player.x+5, player.y+8, 1.5, 0, 2*Math.PI);
            ctx.arc(player.x+player.w-9, player.y+8, 1.5, 0, 2*Math.PI);
            ctx.fill();

            // ---- game over overlay if not active ----
            if (!gameActive) {
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#000000aa';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.font = 'bold 40px "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#ffdbb5';
                ctx.shadowColor = '#6b1a1a';
                ctx.shadowBlur = 14;
                ctx.fillText('‚ò†Ô∏è', 200, 170);
                ctx.font = 'bold 34px sans-serif';
                ctx.fillText('GAME OVER', 160, 250);
            }

            // reset shadow
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            ctx.shadowColor = 'transparent';
        }

        // helper canvas roundRect
        CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            this.moveTo(x + r, y);
            this.lineTo(x + w - r, y);
            this.quadraticCurveTo(x + w, y, x + w, y + r);
            this.lineTo(x + w, y + h - r);
            this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            this.lineTo(x + r, y + h);
            this.quadraticCurveTo(x, y + h, x, y + h - r);
            this.lineTo(x, y + r);
            this.quadraticCurveTo(x, y, x + r, y);
            return this;
        };

        // ---------- GAME LOOP ----------
        function gameLoop() {
            updateGame();
            draw();
            animationId = requestAnimationFrame(gameLoop);
        }

        // ---------- EVENT HANDLERS (keyboard) ----------
        function handleKeyDown(e) {
            const key = e.key;
            if (key === 'ArrowLeft' || key === 'Left' || key === 'ArrowRight' || key === 'Right') {
                e.preventDefault();   // prevent scrolling
            }

            if (!gameActive) return;  // ignore moves when game over

            if (key === 'ArrowLeft' || key === 'Left') {
                leftPressed = true;
            } else if (key === 'ArrowRight' || key === 'Right') {
                rightPressed = true;
            }
        }

        function handleKeyUp(e) {
            const key = e.key;
            if (key === 'ArrowLeft' || key === 'Left') {
                leftPressed = false;
                e.preventDefault();
            } else if (key === 'ArrowRight' || key === 'Right') {
                rightPressed = false;
                e.preventDefault();
            }
        }

        // disable arrow page movement globally while game focused
        window.addEventListener('keydown', function(e) {
            if (e.key.startsWith('Arrow')) {
                e.preventDefault();
            }
        }, { passive: false });

        // specific for game control (also prevent if needed)
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);

        // restart button
        document.getElementById('restartButton').addEventListener('click', () => {
            resetGame();
        });

        // prevent context menu / touch events from interfering
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // start the game
        resetGame();               // sets initial active = true, score 0 etc
        gameLoop();

        // clean up animation on page unload (optional)
        window.addEventListener('beforeunload', () => {
            if (animationId) cancelAnimationFrame(animationId);
        });

        // (optional) touch / mobile? basic: disable right click etc. but we keep it desktop friendly
    })();


    window.addEventListener('online', function() {
    if (confirm('Connection restored! Go back to portfolio?')) {
        window.location.href = 'index.html';
    }
});
</script>
</body>
</html>